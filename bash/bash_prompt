#
#===================================================================================================
# Color Codes {{{1
#===================================================================================================
# Foreground/Background Color Codes
  # 30/40 : black
  # 31/41 : red
  # 32/42 : green
  # 33/43 : yellow
  # 34/44 : blue
  # 35/45 : magenta
  # 36/46 : cyan
  # 37/47 : white
#
# Attribute Codes
  #  0 : Normal
  #  1 : Bold
  #  2 : Normal
  #  3 : Italics*
  #  4 : Underline
  #  5 : Blink
  #  6 : Outline
  #  7 : Reverse FG and BG Colors
  #  8 : Invisible (FG color is made same as BG)
  #  9 : Strike-out*
  # 22 : Bold Off
  # 23 : Italics Off
  # 24 : Underline Off
  # 25 : Blink Off
  # 27 : Reverse Off
  # 29 : Strike-out Off
#
# Syntax
# zsh: %{\e[<attrib1>;<attrib2>...;<fg>;<bg>m%}
# bash: \[\033[<attrib1>;<fg>m\]


# Using colors based on the color command
# Color command generates the hashes 'fg', 'fg_bold', 'fg_no_bold', 'bg', 'bg_bold', 'bg_no_bold'
# The keys of the above hashes are 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' and 'white'
#
# The following code is required to use hash based call
#  setopt PROMPT_SUBST
#  autoload colors zsh/terminfo
#  if [[ "$terminfo[colors]" -ge 8 ]]; then
#    colors
#  fi
#
# Syntax : %{$bg_bold[red]$fg[white]%}
# normal=$terminfo[sgr0]

#===================================================================================================
# BASH Prompt
#===================================================================================================
function setprompt {
  # This function should always point to whatever prompt is desired.
  # The desired function shouldn't be called directly as the chdir() function in bash_func only calls this function
  preprompt_philmod
  setprompt_philmod
}

#===================================================================================================
# Phil's ZSH Prompt (http://aperiodic.net/phil/prompt) {{{1
#===================================================================================================
#function precmd {
#
#    local TERMWIDTH
#    (( TERMWIDTH = ${COLUMNS} - 1 ))
#
#
#    ###
#    # Truncate the path if it's too long.
#
#    PR_FILLBAR=""
#    PR_PWDLEN=""
#
#    local promptsize=${#${(%):---(%n@%m:%l)---()--}}
#    local pwdsize=${#${(%):-%~}}
#
#    if [[ "$promptsize + $pwdsize" -gt $TERMWIDTH ]]; then
#      ((PR_PWDLEN=$TERMWIDTH - $promptsize))
#    else
#  PR_FILLBAR="\${(l.(($TERMWIDTH - ($promptsize + $pwdsize)))..${PR_HBAR}.)}"
#    fi
#
#
#    ###
#    # Get APM info.
#
#    if which ibam > /dev/null; then
#  PR_APM_RESULT=`ibam --percentbattery`
#    elif which apm > /dev/null; then
#  PR_APM_RESULT=`apm`
#    fi
#}
#
#
#setopt extended_glob
#preexec () {
#    if [[ "$TERM" == "screen" ]]; then
#  local CMD=${1[(wr)^(*=*|sudo|-*)]}
#  echo -n "\ek$CMD\e\\"
#    fi
#}
#
#
#setprompt () {
#    ###
#    # Need this so the prompt will work.
#
#    setopt prompt_subst
#
#
#    ###
#    # See if we can use colors.
#
#    autoload colors zsh/terminfo
#    if [[ "$terminfo[colors]" -ge 8 ]]; then
#  colors
#    fi
#    for color in RED GREEN YELLOW BLUE MAGENTA CYAN WHITE; do
#  eval PR_$color='%{$terminfo[bold]$fg[${(L)color}]%}'
#  eval PR_LIGHT_$color='%{$fg[${(L)color}]%}'
#  (( count = $count + 1 ))
#    done
#    PR_NO_COLOUR="%{$terminfo[sgr0]%}"
#
#
#    ###
#    # See if we can use extended characters to look nicer.
#
#    typeset -A altchar
#    set -A altchar ${(s..)terminfo[acsc]}
#    PR_SET_CHARSET="%{$terminfo[enacs]%}"
#    PR_SHIFT_IN="%{$terminfo[smacs]%}"
#    PR_SHIFT_OUT="%{$terminfo[rmacs]%}"
#    PR_HBAR=${altchar[q]:--}
#    PR_ULCORNER=${altchar[l]:--}
#    PR_LLCORNER=${altchar[m]:--}
#    PR_LRCORNER=${altchar[j]:--}
#    PR_URCORNER=${altchar[k]:--}
#
#
#    ###
#    # Decide if we need to set titlebar text.
#
#    case $TERM in
#  xterm*)
#      PR_TITLEBAR=$'%{\e]0;%(!.-=*[ROOT]*=- | .)%n@%m:%~ | ${COLUMNS}x${LINES} | %y\a%}'
#      ;;
#  screen)
#      PR_TITLEBAR=$'%{\e_screen \005 (\005t) | %(!.-=[ROOT]=- | .)%n@%m:%~ | ${COLUMNS}x${LINES} | %y\e\\%}'
#      ;;
#  *)
#      PR_TITLEBAR=''
#      ;;
#    esac
#
#
#    ###
#    # Decide whether to set a screen title
#    if [[ "$TERM" == "screen" ]]; then
#  PR_STITLE=$'%{\ekzsh\e\\%}'
#    else
#  PR_STITLE=''
#    fi
#
#
#    ###
#    # APM detection
#
#    if which ibam > /dev/null; then
#  PR_APM='$PR_RED${${PR_APM_RESULT[(f)1]}[(w)-2]}%%(${${PR_APM_RESULT[(f)3]}[(w)-1]})$PR_LIGHT_BLUE:'
#    elif which apm > /dev/null; then
#  PR_APM='$PR_RED${PR_APM_RESULT[(w)5,(w)6]/\% /%%}$PR_LIGHT_BLUE:'
#    else
#  PR_APM=''
#    fi
#
#
#    ###
#    # Finally, the prompt.
#
#    PROMPT='$PR_SET_CHARSET$PR_STITLE${(e)PR_TITLEBAR}\
#$PR_CYAN$PR_SHIFT_IN$PR_ULCORNER$PR_BLUE$PR_HBAR$PR_SHIFT_OUT(\
#$PR_GREEN%(!.%SROOT%s.%n)$PR_GREEN@%m:%l\
#$PR_BLUE)$PR_SHIFT_IN$PR_HBAR$PR_CYAN$PR_HBAR${(e)PR_FILLBAR}$PR_BLUE$PR_HBAR$PR_SHIFT_OUT(\
#$PR_MAGENTA%$PR_PWDLEN<...<%~%<<\
#$PR_BLUE)$PR_SHIFT_IN$PR_HBAR$PR_CYAN$PR_URCORNER$PR_SHIFT_OUT\
#
#$PR_CYAN$PR_SHIFT_IN$PR_LLCORNER$PR_BLUE$PR_HBAR$PR_SHIFT_OUT(\
#%(?..$PR_LIGHT_RED%?$PR_BLUE:)\
#${(e)PR_APM}$PR_YELLOW%D{%H:%M}\
#$PR_LIGHT_BLUE:%(!.$PR_RED.$PR_WHITE)%#$PR_BLUE)$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT\
#$PR_CYAN$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT\
#$PR_NO_COLOUR '
#
#    RPROMPT=' $PR_CYAN$PR_SHIFT_IN$PR_HBAR$PR_BLUE$PR_HBAR$PR_SHIFT_OUT\
#($PR_YELLOW%D{%a,%b%d}$PR_BLUE)$PR_SHIFT_IN$PR_HBAR$PR_CYAN$PR_LRCORNER$PR_SHIFT_OUT$PR_NO_COLOUR'
#
#    PS2='$PR_CYAN$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT\
#$PR_BLUE$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT(\
#$PR_LIGHT_GREEN%_$PR_BLUE)$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT\
#$PR_CYAN$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT$PR_NO_COLOUR '
#}
#
# End of Phil's ZSH Prompt
#--------------------------


#===================================================================================================
# Mod of Phil's ZSH Prompt {{{1
#===================================================================================================
function precmd {
  local TERMWIDTH
  (( TERMWIDTH = ${COLUMNS} - 1 ))

  ###
  # Truncate the path if it's too long.
  PR_FILLBAR=""
  PR_PWDLEN=""
  modPWD="${PWD/#$HOME/~}"

  local promptsize=${#${(%):-()--(%h)-}}
  local pwdsize=${#${(%):-${modPWD} } }

  if [[ "$promptsize + $pwdsize" -gt $TERMWIDTH ]]; then
    ((PR_PWDLEN=$TERMWIDTH - $promptsize))
  else
    PR_FILLBAR="\${(l.(($TERMWIDTH - ($promptsize + $pwdsize)))..${PR_HBAR}.)}"
  fi
}

setprompt_philmod () {
  ###
  # Need this so the prompt will work.
  #setopt PROMPT_SUBST


  ###
  # See if we can use colors.
  autoload colors zsh/terminfo
  if [[ "$terminfo[colors]" -ge 8 ]]; then
      colors
  fi
  blink=$'\e[5m'
  blink_off=$'\e[25m'
    normal="%{$terminfo[sgr0]%}"


    ###
    # See if we can use extended characters to look nicer.
    typeset -A altchar
    set -A altchar ${(s..)terminfo[acsc]}
    PR_SET_CHARSET="%{$terminfo[enacs]%}"
    PR_SHIFT_IN="%{$terminfo[smacs]%}"      # Enter extended character input mode
    PR_SHIFT_OUT="%{$terminfo[rmacs]%}"     # Exit extended character input mode
    PR_HBAR=${altchar[q]:--}
    PR_ULCORNER=${altchar[l]:--}
    PR_LLCORNER=${altchar[m]:--}
    PR_LRCORNER=${altchar[j]:--}
    PR_URCORNER=${altchar[k]:--}


    ###
    # Decide if we need to set titlebar text.
    case $TERM in
  xterm*)
      PR_TITLEBAR=$'%{\e]0;%n@%m: %~\a%}'
      ;;
  *)
      PR_TITLEBAR=''
      ;;
    esac


    ###
    # Finally, the prompt.
    PROMPT='$PR_SET_CHARSET${(e)PR_TITLEBAR}\
%{$fg_no_bold[white]%}$PR_SHIFT_IN$PR_ULCORNER$PR_SHIFT_OUT\
%{$fg_bold[black]%}(%{$fg_no_bold[green]%}%h%{$fg_bold[black]%})\
%{$fg_no_bold[white]%}$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT\
%{$fg_bold[black]%}(%{%(?.$fg_bold[green].$fg_bold[red])%}%$PR_PWDLEN<...<${modPWD}%<<%{$fg_bold[black]%})\
%{$fg_no_bold[white]%}$PR_SHIFT_IN${(e)PR_FILLBAR}$PR_URCORNER$PR_SHIFT_OUT\

$PR_SHIFT_IN$PR_LLCORNER$PR_HBAR$PR_SHIFT_OUT\
%(?.%{$fg_bold[green]%}(^_^%).%{$fg_bold[red]%}(@_@%)) \
%{%(!.$fg_bold[red].$fg_bold[white])%}%#$normal '

    RPROMPT=' %{$fg_bold[black]%}(%{$fg_no_bold[yellow]%}%D{%H:%M %b %d, %a}%{$fg_bold[black]%})\
%{$fg_no_bold[white]%}$PR_SHIFT_IN$PR_LRCORNER$PR_SHIFT_OUT$normal'

    PS2='%{$fg_no_bold[white]%}%_ >$normal '
}



#===================================================================================================
# Misc Prompts {{{1
#===================================================================================================
function setprompt_misc() {
  setopt PROMPT_SUBST
  autoload colors zsh/terminfo
  if [[ "$terminfo[colors]" -ge 8 ]]; then
    colors
  fi

  blink=$'\e[5m'
  blink_off=$'\e[25m'
  normal="%{$terminfo[sgr0]%}"

  #PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
  #PS1="\`if [ \$? = 0 ]; then echo \[\e[32m\]^_^\[\e[0m\]; else echo \[\e[31m\]@_@\[\e[0m\]; fi\`[!\!] \W/$ "
  #PS1="[\!] \W/$ "
  #PS1="\[\e[0;33m\][!\!]\`if [[ \$? = "0" ]]; then echo "\\[\\e[32m\\]"; else echo "\\[\\e[31m\\]"; fi\` \`if [[ `pwd|wc -c` -gt 18 ]]; then echo "\\W"; else echo "\\w"; fi\`/\$\[\e[0m\] "
  #PS1="\[\e[0;33m\][!\!]\[\e[0m\] \`if [ \$? = 0 ]; then echo '\[\e[1;32m\]\w \n^_^\[\e[0m\]'; else echo '\[\e[1;31m\]\w\n@_@\[\e[0m\]'; fi\` $ "
  #PS1="\[\e[1;30m\](\[\e[0;33m\]!\!\[\e[1;30m\])-(\`if [ \$? = 0 ]; then echo '\[\e[1;32m\]\w\[\e[1;30m\])\n\[\e[1;32m\]^_^'; else echo '\[\e[1;31m\]\w\[\e[1;30m\])\n\[\e[1;31m\]@_@'; fi\` \[\e[1;30m\]$ \[\e[0m\]"
  PS1="\n\[\e[0;37m\](\[\e[0;33m\]!\!\[\e[0;37m\])-(\`if [ \$? = 0 ]; then echo '\[\e[1;32m\]\w\[\e[0;37m\])\n(\[\e[1;32m\]^_^\[\e[0;37m\])'; else echo '\[\e[1;31m\]\w\[\e[0;37m\])\n(\[\e[1;31m\]@_@\[\e[0;37m\])'; fi\` \[\e[0;37m\]$ \[\e[0m\]"
  #PS1="${bg_red_fg_white_blink}%(t.DING!.)%(30t.DONG!.)${att_normal}${fg_dgray}[${fg_brown}%h${fg_dgray}]-(%(?.${fg_lgreen}.${fg_lred})%~${fg_dgray})${fg_lgray}%# ${att_normal}"
  #PS1="[%(t.${blink}%{${bg[red]}${fg_no_bold[white]}%}DING!${normal}.%(30t.${blink}%{${bg[red]}${fg_no_bold[white]}%}DONG!${normal}.%{$fg_bold[yellow]%}%D{%H:%M}))${normal}] "
  #PS1='[%h]-($modPWD)$ '
  RPS1=" [%h]"
}


#===================================================================================================
# Mod of SJL's prompt {{{1
#===================================================================================================
#
#  SJL's Prompt
#  Credit for ideas/info: Phil!'s ZSH Prompt, Bashish, TERMWIDE prompt
#                         Bash Prompt Howto
#                         http://stevelosh.com/blog/2010/02/my-extravagant-zsh-prompt/
#
# Example:
# ┌ kshenoy @ svvgar-nx16 in ~/.vim ───────────────────── 03:57pm Aug 02, Fri
# └ (^_^) ➤
#
##### code ####
## Use bash builtin checkwinsize option for terminals which fail to properly
## set the $COLUMNS variable. (bug workaround)
shopt -s checkwinsize

## This function is run at every prompt update, keeping our variables updated.
## Bash's PROMPT_COMMAND option handles this (see end of this function).
function preprompt_sjlmod {

  # This has to be placed first
  local cmd_exit="$?"

  # We use this instead of $COLUMNS as when a shell is starting, the $COLUMNS variable is not set
  local columns=$(tput cols)

  # Colors
  local prc_norm='\[\e[0m\]'            # clear all colors
  local prc_bg='\[\e[38;5;250m\]'
  local prc_white=${prc_norm}
  local prc_red='\[\e[38;5;160m\]'
  local prc_lime='\[\e[38;5;154m\]'
  local prc_cherry='\[\e[38;5;161m\]'
  local prc_yellow='\[\e[38;5;221m\]'
  local prc_orange='\[\e[38;5;214m\]'
  local prc_rose='\[\e[38;5;211m\]'

  # Set line graphics
  local pr_dash="─"
  #local pr_dash="━"
  local pr_ulcorner="┌"
  local pr_llcorner="└"
  #local pr_urcorner="┐"
  #local pr_lrcorner="┘"

  #local pr_dash="-"
  #local pr_ulcorner=""
  #local pr_llcorner=""

  # If root user then colour the arrow red.
  if [ "${UID}" = 0 ]; then
    local prc_user_symbol=${prc_red}
  else
    local prc_user_symbol=${prc_white}
  fi

  # The info variables
  local pr_pwd=$PWD
  pr_pwd=${pr_pwd/#$HOME/\~}
  [ -n "$as" ] && pr_pwd=${pr_pwd/#$as/\~aspen}

  # Force time to US Mountain Time (we do this here as well as in .bashrc as sourcing some env files overwrites this)
  local pr_time="$(TZ=US/Mountain date +%I:%M%P\ %b\ %d,\ %a) "
  #local pr_time=" $( date +%I:%M%P\ %b\ %d,\ %a)"
  local pr_user="$(whoami) "
  #local pr_user_symbol=" ➤"
  local pr_user_symbol=" \$"
  local pr_user_host_sep="@ "
  local pr_pwd_sep="in "
  local pr_host="$(hostname) "

  # set length of our important info
  local pr_info="${pr_ulcorner} ${pr_user}${pr_user_host_sep}${pr_host}${pr_pwd_sep}${pr_pwd} ${pr_time}"
  let pr_fillsize=${columns}-${#pr_info}

  # If info is wider than the screen, drop the time display
  if [ "$pr_fillsize" -lt "0" ]; then
    pr_time=""
    pr_info="${pr_ulcorner} ${pr_user}${pr_user_host_sep}${pr_host}${pr_pwd_sep}${pr_pwd} "
    let pr_fillsize=${columns}-${#pr_info}
  fi

  # If the info still can't fit, drop user and domain info
  if [ "$pr_fillsize" -lt "0" ]; then
    pr_user=""
    pr_user_host_sep=""
    pr_host=""
    pr_info="${pr_ulcorner} ${pr_pwd_sep}${pr_pwd} "
    let pr_fillsize=${columns}-${#pr_info}
  fi
  pr_pwd_sep="${prc_white}${pr_pwd_sep}"

  # If the info still can't fit, truncate PWD
  if [ "$pr_fillsize" -lt "0" ]; then
    pr_pwd_sep="..."
    while [ "$pr_fillsize" -lt 0 ]; do
      pr_pwd=`echo $pr_pwd | sed 's|^/\?[^/]*/||'`
      pr_info="${pr_ulcorner} ${pr_pwd_sep}${pr_pwd} "
      let pr_fillsize=${columns}-${#pr_info}
    done
    pr_pwd_sep="${prc_lime}${pr_pwd_sep}"
  fi
  pr_pwd="${prc_lime}${pr_pwd}${pr_norm}"

  local pr_fill=""
  let pr_fillsize=$pr_fillsize-1
  while [ "$pr_fillsize" -gt "0" ]; do
    pr_fill="${pr_fill}${pr_dash}"
    let pr_fillsize=${pr_fillsize}-1
  done
  pr_fill="${pr_fill} "

  # Color pr_pwd based upon exit status of last command
  if [ "$cmd_exit" = "0" ]; then
    pr_cmd_exit="${prc_lime} (^_^)${prc_norm}"
  else
    pr_cmd_exit="${prc_red} (@_@)${prc_norm}"
  fi

  PS1="\n${prc_norm}${prc_bg}${pr_ulcorner} ${prc_cherry}${pr_user}${prc_white}${pr_user_host_sep}${prc_orange}${pr_host}"
  PS1+="${pr_pwd_sep}${pr_pwd} "
  PS1+="${prc_bg}${pr_fill}${prc_orange}${pr_time}"
  PS1+="\n${prc_bg}${pr_llcorner}${pr_cmd_exit}${prc_user_symbol}${pr_user_symbol}${prc_norm} "

  PS2=" ${prc_user_symbol}${prc_norm} "

  # Evaluate dynamic variables ( Not required for prompt )
  declare -F dyn_vars && dyn_vars
}
PROMPT_COMMAND=preprompt_sjlmod
