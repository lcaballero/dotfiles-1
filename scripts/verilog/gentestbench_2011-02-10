#!/usr/bin/perl
#==================================================================================================#
# Script to generate testbench, ncverilog command for simulation                                   #
#                                                                                                  #
# testbench generation would be in very elementary terms the following                             #
#                                                                                                  #
# Obtain PIN LIST from Verilog File                                                                #
# Convert input pins to reg                                                                        #
# Convert output/inout pins to wire                                                                #
# Convert template signals to verilog                                                              #
#                                                                                                  #
# Changelog:-                                                                                      #
# ------------                                                                                     #
# Created by Somu Ghosh (a0393049)                                                                 #
#                                                                                                  #
# 2010-04-13 : Kartik Shenoy (a0393831)                                                            #
# - Template file can accept input pins with levels L,H,Y which are converted to 0,1,X in verilog  #
#   testbench                                                                                      #
# - Template file can accept output pins with level M which is converted to X in the verilog       #
#   testbench                                                                                      #
#                                                                                                  #
#==================================================================================================#

## Modules ========================================================================================#

use strict;
use warnings;
#use diagnostics;
use Getopt::Long;


## Command-line parameter handling ================================================================#

GetOptions(
	        'i=s' => \my $template,
            'y=s' => \my $libdir,
	        'o=s' => \my $testbench,
	'verbose|v:i' => \my $verbose,
);


## File Handling ==================================================================================#

$template||=$ARGV[0] unless defined $template;
defined($template) or die("ERROR: Template file not specified. Usage $0 [-i] <template> [-y] <libdir> -o <testbench>\n");
die("ERROR : $template not found.\n") unless(-e $template);
open(my $tpl,"<",$template) or die("ERROR: Unable to open $template for reading.\n");

$libdir||=$ARGV[1];
defined($libdir) or die("ERROR: Library directory not specified. Usage $0 [-i] <template> [-y] <libdir> -o <testbench>\n");
die("ERROR : $libdir not found.\n") unless(-e $libdir);
#open(my $pin,"<",$libdir) or die("ERROR: Unable to open $libdir for reading.\n");

$testbench||=$ARGV[2] unless defined $testbench;
unless(defined $testbench){
    ($testbench) = $template =~ /(.*?)(?:\.tpl)?$/;
    $testbench =~ s/\.v$//;
    $testbench .= "_TB";
    warn("INFO: Output testbench not specified. Writing the output to ${testbench}.v\n");
}
open(my $vtb,">","${testbench}.v") or die("ERROR: Unable to open ${testbench}.v for writing.\n");


## ================================================================================================#

my @keywords=qw(verilog_models input_pins output_pins inout_pins timescale timestep pin_order waitstep);
my %templatehash;
my %pinlist;
my %pinhash;
my $simbits=0;


## Read Template and Parse Values =================================================================#

while(<$tpl>){
	chomp; s/[\n\t\f\s]//g;
	next unless $_; next if /^#/;
	
	my @fields=split(/:/);
	if($#fields==1){
        if(grep(/$fields[0]/,@keywords)){
            $templatehash{$fields[0]}=$fields[1];
        }else{
            die "ERROR: Illegal pin name $fields[0] found in $template\n" unless($fields[0] =~ /^[A-Za-z]+\w*$/);
            if($fields[1] =~ /^[10LHXYZMC]*$/i){
                $pinlist{$fields[0]}=$fields[1];
                $simbits = (length($fields[1]) > $simbits ? length($fields[1]) : $simbits);
            }else{
                die "ERROR: Illegal signal levels for pin $fields[0] on line no. $.\n";
            }
        }
	}else{
		warn "Illegal Statement $_ at line no. $.. Ignoring...\n";
	}
}


## Verifying Inputs ===============================================================================#

my @pin_order=split(/,/,$templatehash{pin_order});
my @input_pins=split(/,/,$templatehash{input_pins});
my @output_pins=split(/,/,$templatehash{output_pins});
my @inout_pins=split(/,/,$templatehash{inout_pins});

# Checking if all pins specified in pin_order are present in either of input_pins, output_pins or inout_pins
die "ERROR: pin_order not specified. Will Terminate Now!!!\n" unless $templatehash{pin_order};
foreach my $pin (@pin_order){
    die "ERROR: Illegal pin name $pin found in pin_order\n" unless($pin =~ /^[A-Za-z]+\w*$/);
    grep(/$pin/,@input_pins) or grep(/$pin/,@output_pins) or grep(/$pin/,@inout_pins) or 
        die "ERROR: $pin of pin_order not in INPUT/OUTPUT/INOUT. Exiting...\n";
}

# Checking if all pins specified in input_pins are present in pin_order
# Checking if signal vectors have been specified for the input pin
die "ERROR: input_pins not specified. Will Terminate Now!!!" unless $templatehash{input_pins};
foreach my $pin (@input_pins){
    grep(/$pin/,@pin_order) or die "ERROR: Input pin $pin not found in pin_order.\n";
    die "ERROR: Illegal pin name $pin found in input_pins.\n" unless($pin =~ /^[A-Za-z]+\w*$/);
    die "ERROR: No Signal Specified for Input pin $pin\n" unless(defined $pinlist{$pin});
    $pinhash{$pin}=$pinlist{$pin};
    delete $pinlist{$pin};
    s/L/0/gi, s/H/1/gi, s/[MY]/X/gi for $pinhash{$pin};
}

# Checking if all pins specified in output_pins are present in pin_order
# If no signal values are specified for output pin, making it X and comparison won't be done
die "ERROR: output_pins not specified. Will Terminate Now!!!\n" unless $templatehash{output_pins};
foreach my $pin (@output_pins){
    grep(/$pin/,@pin_order) or die "ERROR: Output pin $pin not found in pin_order.\n";
    die "ERROR: Illegal pin name $pin found in output_pins\n" unless($pin =~ /^[A-Za-z]+\w*$/);
    unless(defined $pinlist{$pin}){
        warn "WARNING: No Signal Specified for OutPut pin $pin. Creating output pin defaulting to don't care...\n";
        $pinhash{$pin}="X";
    }else{
        $pinhash{$pin}=$pinlist{$pin};
        delete $pinlist{$pin};
        s/L/0/gi, s/H/1/gi, s/[MY]/X/gi for $pinhash{$pin};
    }
}

# Checking if all pins specified in inout_pins are present in pin_order
# Checking if signal vectors have been specified for the inout pin
if(defined $templatehash{inout_pins} and $templatehash{inout_pins}!~/^\s$/){
    print "INFO: inout_pins have been specified. Please ensure that the input or expected output are specified correctly\n";
    foreach my $pin (@inout_pins){
        grep(/$pin/,@pin_order) or die "ERROR: Inout pin $pin not found in pin_order.\n";
        die "ERROR: Illegal pin name $pin found in inout_pins\n" unless($pin =~ /^[A-Za-z]+\w*$/);
        die "ERROR: No Signal Specified for Inout pin $pin\n" unless(defined $pinlist{$pin});
        $pinhash{$pin}=$pinlist{$pin};
        delete $pinlist{$pin};
        s/L/0/gi, s/H/1/gi, s/[MY]/X/gi for $pinhash{$pin};
    }
}else{
    $templatehash{inout_pins}="";
}

# Checking to see if extra signal vectors have been specified for pins not mentioned in pin_order and ignoring them
my @tmp=(keys %pinlist);
print @tmp;
warn "WARNING: Extra signal definitions found for @tmp\n" unless($#tmp == -1);
undef @tmp;

if(defined $templatehash{timescale}){
	unless($templatehash{timescale} =~ /^\d+[fpnum]?s\/\d+[fpnum]?s$/){
		warn "WARNING: timescale ($templatehash{timescale}) value not in correct format. Using default value 1ps/1ps\n";
		$templatehash{timescale}="1ps/1ps";
	}
}else{
	warn "WARNING: timescale value not specified. Using default value 1ps/1ps\n";
	$templatehash{timescale}="1ps/1ps";
}

if(defined $templatehash{timestep}){
	unless($templatehash{timestep} =~ /^\d+$/){
		warn "WARNING: timestep value not in correct format. Using default value 10\n";
		$templatehash{timestep} = "10";
	}
}else{
	warn "WARNING: timestep value not specified. Using default value 10\n";
	$templatehash{timestep} = "10";
}

if(defined $templatehash{waitstep}){
	unless($templatehash{waitstep} =~ /^\d+$/){
		warn "WARNING: waitstep value not in correct format. Using default value 10\n";
		$templatehash{waitstep} = "10";
	}
}else{
	warn "WARNING: waitstep value not specified. Using default value 10\n";
	$templatehash{waitstep} = "10";
}

$templatehash{timescale}=~/^(\d+)(\w+)/;
$_=$simbits*($templatehash{timestep}+$templatehash{waitstep})*$1;

# Print Values Obtained
print "\nFollowing Data found in template\n";
print "---------------------------------\n";
print "verilog_model  : " . $templatehash{verilog_model} . "\n";
print "timescale      : " . $templatehash{timescale} . "\n";
print "timestep       : " . $templatehash{timestep} . "\n";
print "waitstep       : " . $templatehash{waitstep} . "\n";
#print "input_pins     : " . $templatehash{input_pins} . "\n";
#print "output_pins    : " . $templatehash{output_pins} . "\n";
#print "inout_pins     : " . $templatehash{inout_pins} . "\n";
#print "pin_order      : " . $templatehash{pin_order} . "\n";
print "Total Sim Time : " . "$simbits*($templatehash{timestep}+$templatehash{waitstep})*".(split(/\//,$templatehash{timescale}))[0]." = $_$2\n";


# Check verilog model file
open(my $vlg, "$libdir/$templatehash{verilog_model}.v") or die "Couldn't open $libdir/$templatehash{verilog_model}.v for reading\n";
close($vlg);


## Generate testbench =============================================================================#

chomp(my $id=`whoami`);
#my $name=(split(/\s+/,`de $id | grep "Common name"`))[4]." ".(split(/\s+/,`de $id | grep "Common name"`))[5];
chomp(my $toc=`date`); 

print $vtb "// Verilog Test Bench Setup created by gentestbench 
// Created by: $id
// Created on: $toc
                                                           
`timescale $templatehash{timescale}
                                                           
module $testbench ()\; \n";

# List of Input pins specified as reg
my $pinalign = 0;
print $vtb "\n// Input Pins\n";
foreach my $pin (@input_pins){
    print $vtb "reg $pin;\n";
    $pinalign = length($pin) if($pinalign < length($pin));
}

# List of Output pins specified as wire
print $vtb "\n// Output Pins\n";
foreach my $pin (@output_pins){
    print $vtb "wire $pin;\n";
}

# List of Inout pins specified as wire
print $vtb "\n// Inout Pins\n";
foreach my $pin (@inout_pins){
    print $vtb "wire $pin;\n";
}

# Extra signal specified as reg for expected values of outputs
print $vtb "\n// Expected Values for outputs and inouts - Internal nets\n";
foreach my $pin (@output_pins,@inout_pins){
    print $vtb "reg ${pin}_expected;\n";
    $pinalign = length($pin."_expected") if($pinalign < length($pin."_expected"));
}

$pinalign+=2;

print $vtb "\ninteger failures=0,counter=0;\n";
print $vtb "\n\ninitial \nbegin
\t\$dumpfile\(\"${testbench}.vcd\"\);
\t\$dumpvars\(0," . (split("/",$testbench))[-1] . "\);
\t\$display();
\n\t#0\t\t// Bit 0\n";

for(my $simcount=0;$simcount < $simbits;$simcount++){
    foreach my $pin (@input_pins){
		my $pinval = (split(//,$pinhash{$pin}))[$simcount];
        next unless defined $pinval;
		printf $vtb "\t%-*s = %s\;\n",$pinalign,$pin,"1\'b$pinval" if($pinval=~/[01XZ]/i);
    }
    foreach my $pin (@output_pins){
		my $pinval = (split(//,$pinhash{$pin}))[$simcount];
		next unless defined $pinval;
		printf $vtb "\t%-*s = %s\;\n",$pinalign,"${pin}_expected","1\'b$pinval" if($pinval=~/[01XZ]/i);
    }
    foreach my $pin (@inout_pins){
		my $pinval = (split(//,$pinhash{$pin}))[$simcount];
		next unless defined $pinval;
        printf $vtb "\t%-*s = %s\;\t// inout\n",$pinalign,"${pin}_expected","1\'b$pinval";
    }
	print $vtb "\t#$templatehash{waitstep}\n\tcounter = counter + 1\;\n\tevaluate_testbench\;\n";
	if($simcount < ($simbits -1)){
        $_=$simcount+1;
		print $vtb "\n\t#$templatehash{timestep}\t// Bit $_\n";
	}else{
		print $vtb "\n\tterminate_testbench\;\n";
	}
}
print $vtb "end\n\n";


# Mux the value of inout pins with Z, controlled by the <inout>_in pin;
# Give muxed value to DUT
foreach my $pin (@inout_pins){
    print $vtb "assign $pin = ${pin}_expected;\n";
}

print $vtb "
$templatehash{verilog_model} $templatehash{verilog_model}_dut ($templatehash{pin_order})\;\n

task terminate_testbench\;
begin
\t\$display\(\"Simulation found %0d failures\\n\", failures\)\;
\t\$finish\;
end
endtask
\n
task evaluate_testbench;
begin\n";

print $vtb "// Outputs comparison\n";
# Compare simulated value of outputs and inouts with expected value
foreach my $pin (@output_pins,@inout_pins){
#    print $vtb "\t\t\$strobe_compare(${pin}_expected,$pin);\n";
	print $vtb "\tif \(${pin}_expected !== 1'bX\) begin\n";
    print $vtb "\t\tif \(${pin}_expected !== $pin\) begin\n";
    print $vtb "\t\t\tfailures = failures + 1;\n";
    print $vtb "\t\t\$display\(\"Sim Failed for $pin in \%0d. Expected=\%d, Simulated=\%d\", counter,${pin}_expected,$pin)\;\n";
    print $vtb "\t\tend\n";
	print $vtb "\tend\n";
}


print $vtb "end\nendtask\nendmodule\n";
close ($vtb);

print "\nTo verify your simulation execute\n
\\rm -rf INCA_libs ; /apps/ame/bin/ncverilog ./${testbench}.v -y ./${libdir} +libext+.v -l ${testbench}.log +define+TI_functiononly +define+TI_pupdmodeled +nocopyright +access+r\n";
