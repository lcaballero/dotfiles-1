#!/usr/bin/perl
#==================================================================================================#
#                                                                                                  #
# DESCRIPTION:                                                                                     #
#   Script to generate verilog testbench from input template file                                  #
#                                                                                                  #
# SYNTAX:                                                                                          #
#   gentestbench [-i] <template> [-y] <libdir> [[-o] <testbench>]                                  #
#                                                                                                  #
# REQUIRED:                                                                                        #
#   Template file containing signal levels at different times                                      #
#                                                                                                  #
# CHANGELOG:                                                                                       #
# Created by Somu Ghosh (a0393049)                                                                 #
#                                                                                                  #
# 2010-04-13 : Kartik Shenoy (a0393831)                                                            #
#   - Template file can accept input pins with levels L,H,Y which are converted to 0,1,X in        #
#     verilog testbench                                                                            #
#   - Template file can accept output pins with level M which is converted to X in the verilog     #
#     verilog testbench                                                                            #
#                                                                                                  #
# 2011-02-11 : Kartik Shenoy (a0393831)                                                            #
#   - Added support for inout pins                                                                 #
#   - Signal levels L,H,Y should be used only to signify input and 0,1,M,X,Z only for output       #
#                                                                                                  #
#==================================================================================================#

## Modules ========================================================================================#

use strict;
use warnings;
#use diagnostics;
use Getopt::Long;


## Command-line parameter handling ================================================================#

GetOptions(
            'i=s' => \my $template,
            'y=s' => \my $libdir,
            'o=s' => \my $testbench,
#	'verbose|v:i' => \my $verbose,
);


## File Handling ==================================================================================#

$template||=$ARGV[0] unless defined $template;
defined($template) or die("  ERROR : Specified template file not specified. Usage $0 [-i] <template> [-y] <libdir> -o <testbench>\n");
die("  ERROR : $template not found.\n") unless(-e $template);
open(my $tpl,"<",$template) or die("  ERROR : Unable to open $template for reading.\n");

$libdir||=$ARGV[1];
defined($libdir) or die("  ERROR : Library directory not specified. Usage $0 [-i] <template> [-y] <libdir> -o <testbench>\n");
die("  ERROR : $libdir not found.\n") unless(-e $libdir);

$testbench||=$ARGV[2] unless defined $testbench;
unless(defined $testbench){
    ($testbench) = $template =~ /(.*?)(?:\.tpl)?$/;
    $testbench =~ s/\.v$//;
    $testbench .= "_tb";
    warn("  INFO  : Output testbench not specified. Writing the output to ${testbench}.v\n");
}
open(my $vtb,">","${testbench}.v") or die("  ERROR : Unable to open ${testbench}.v for writing.\n");


## ================================================================================================#

my @keywords=qw(verilog_models input_pins output_pins inout_pins timescale timestep pin_order waitstep);
my %templatehash;
my %pinlist;
my %pinhash;
my $simbits=0;


## Read Template and Parse Values =================================================================#

while(<$tpl>){
	chomp; s/[\n\t\f\s]//g;
	next unless $_; next if /^#/;
	
	my @fields=split(/:/);
	if($#fields==1){
        if(grep(/$fields[0]/,@keywords)){
            $templatehash{$fields[0]}=$fields[1];
        }else{
            die "  ERROR : Illegal pin name $fields[0] found in $template\n" unless($fields[0] =~ /^[A-Za-z]+\w*$/);
            if($fields[1] =~ /^[10LHXYZMC]*$/i){
                $pinlist{$fields[0]}=$fields[1];
                $simbits = (length($fields[1]) > $simbits ? length($fields[1]) : $simbits);
            }else{
                die " ERROR  : Illegal signal levels for pin $fields[0] on line no. $.\n";
            }
        }
	}else{
		warn "  WARN  : Illegal Statement $_ at line no. $.. Ignoring...\n";
	}
}


## Verifying Inputs ===============================================================================#

my @pin_order=split(/,/,$templatehash{pin_order});
my @input_pins=split(/,/,$templatehash{input_pins});
my @output_pins=split(/,/,$templatehash{output_pins});
my @inout_pins;
@inout_pins=split(/,/,$templatehash{inout_pins}) if(defined $templatehash{inout_pins});

# Checking if all pins specified in pin_order are present in either of input_pins, output_pins or inout_pins
die "  ERROR : pin_order not specified. Will Terminate Now!!!\n" unless $templatehash{pin_order};
foreach my $pin (@pin_order){
    die "  ERROR : Illegal pin name $pin found in pin_order\n" unless($pin =~ /^[A-Za-z]+\w*$/);
    grep(/$pin/,@input_pins) or grep(/$pin/,@output_pins) or grep(/$pin/,@inout_pins) or 
        die "  ERROR : $pin of pin_order not in INPUT/OUTPUT/INOUT. Exiting...\n";
}

# Checking if all pins specified in input_pins are present in pin_order
# Checking if signal vectors have been specified for the input pin
die "  ERROR : input_pins not specified. Will Terminate Now!!!" unless $templatehash{input_pins};
foreach my $pin (@input_pins){
    grep(/$pin/,@pin_order) or die "  ERROR : Input pin $pin not found in pin_order.\n";
    die "  ERROR : Illegal pin name $pin found in input_pins.\n" unless($pin =~ /^[A-Za-z]+\w*$/);
    die "  ERROR : No Signal Specified for Input pin $pin\n" unless(defined $pinlist{$pin});
    $pinhash{$pin}=$pinlist{$pin};
    delete $pinlist{$pin};
    s/L/0/gi, s/H/1/gi, s/[MY]/X/gi for $pinhash{$pin};
}

# Checking if all pins specified in output_pins are present in pin_order
# If no signal values are specified for output pin, making it X and comparison won't be done
die "  ERROR : output_pins not specified. Will Terminate Now!!!\n" unless $templatehash{output_pins};
foreach my $pin (@output_pins){
    grep(/$pin/,@pin_order) or die "  ERROR : Output pin $pin not found in pin_order.\n";
    die "  ERROR : Illegal pin name $pin found in output_pins\n" unless($pin =~ /^[A-Za-z]+\w*$/);
    unless(defined $pinlist{$pin}){
        warn "  WARN  : No Signal Specified for OutPut pin $pin. Creating output pin defaulting to don't care...\n";
        $pinhash{$pin}="X";
    }else{
        $pinhash{$pin}=$pinlist{$pin};
        delete $pinlist{$pin};
        s/L/0/gi, s/H/1/gi, s/[MY]/X/gi for $pinhash{$pin};
    }
}

# Checking if all pins specified in inout_pins are present in pin_order
# Checking if signal vectors have been specified for the inout pin
if(defined $templatehash{inout_pins} and $templatehash{inout_pins}!~/^\s$/){
    print "  INFO  : inout_pins have been specified. Please ensure that inputs are specified only as 'L,H,Y' and outputs as '0,1,X,Z,M'.\n";
    foreach my $pin (@inout_pins){
        grep(/$pin/,@pin_order) or die "  ERROR : Inout pin $pin not found in pin_order.\n";
        die "  ERROR : Illegal pin name $pin found in inout_pins\n" unless($pin =~ /^[A-Za-z]+\w*$/);
        die "  ERROR : No Signal Specified for Inout pin $pin\n" unless(defined $pinlist{$pin});
        $pinhash{$pin}=$pinlist{$pin};
        delete $pinlist{$pin};
    }
}else{
    $templatehash{inout_pins}="";
}

# Checking to see if extra signal vectors have been specified for pins not mentioned in pin_order and ignoring them
my @tmp=(keys %pinlist);
print @tmp;
warn "  WARN  : Extra signal definitions found for @tmp\n" unless($#tmp == -1);
undef @tmp;

if(defined $templatehash{timescale}){
	unless($templatehash{timescale} =~ /^\d+[fpnum]?s\/\d+[fpnum]?s$/){
		warn "  WARN  : timescale ($templatehash{timescale}) value not in correct format. Using default value 1ps/1ps\n";
		$templatehash{timescale}="1ps/1ps";
	}
}else{
	warn "  WARN  : timescale value not specified. Using default value 1ps/1ps\n";
	$templatehash{timescale}="1ps/1ps";
}

if(defined $templatehash{timestep}){
	unless($templatehash{timestep} =~ /^\d+$/){
		warn "  WARN  : timestep value not in correct format. Using default value 10\n";
		$templatehash{timestep} = "10";
	}
}else{
	warn "  WARN  : timestep value not specified. Using default value 10\n";
	$templatehash{timestep} = "10";
}

if(defined $templatehash{waitstep}){
	unless($templatehash{waitstep} =~ /^\d+$/){
		warn "  WARN  : waitstep value not in correct format. Using default value 10\n";
		$templatehash{waitstep} = "10";
	}
}else{
	warn "  WARN  : waitstep value not specified. Using default value 10\n";
	$templatehash{waitstep} = "10";
}

$templatehash{timescale}=~/^(\d+)(\w+)/;
$_=$simbits*($templatehash{timestep}+$templatehash{waitstep})*$1;

# Print Values Obtained
print "\n  Following Data found in template\n";
print "  ---------------------------------\n";
print "  verilog_model  : " . $templatehash{verilog_model} . "\n";
print "  timescale      : " . $templatehash{timescale} . "\n";
print "  timestep       : " . $templatehash{timestep} . "\n";
print "  waitstep       : " . $templatehash{waitstep} . "\n";
#print "  input_pins     : " . $templatehash{input_pins} . "\n";
#print "  output_pins    : " . $templatehash{output_pins} . "\n";
#print "  inout_pins     : " . $templatehash{inout_pins} . "\n";
#print "  pin_order      : " . $templatehash{pin_order} . "\n";
print "  Total Sim Time : " . "$simbits*($templatehash{timestep}+$templatehash{waitstep})*".(split(/\//,$templatehash{timescale}))[0]." = $_$2\n";


# Check verilog model file
open(my $vlg, "$libdir/$templatehash{verilog_model}.v") or die "Couldn't open $libdir/$templatehash{verilog_model}.v for reading\n";
close($vlg);


## Generate testbench =============================================================================#

chomp(my $id=`whoami`);
#my $name=(split(/\s+/,`de $id | grep "Common name"`))[4]." ".(split(/\s+/,`de $id | grep "Common name"`))[5];
chomp(my $toc=`date`); 

print $vtb "// Verilog Test Bench Setup created by gentestbench 
// Created by: $id
// Created on: $toc
                                                           
`timescale $templatehash{timescale}
                                                           
module $testbench ()\; \n";

# List of Input pins specified as reg
my $pinalign = 0;
print $vtb "\n// Input Pins\n";
foreach my $pin (@input_pins){
    print $vtb "reg $pin;\n";
    $pinalign = length($pin) if($pinalign < length($pin));
}

# List of Output pins specified as wire
print $vtb "\n// Output Pins\n";
foreach my $pin (@output_pins){
    print $vtb "wire $pin;\n";
}

# List of Inout pins specified as wire
if(defined $templatehash{inout_pins}){
    print $vtb "\n// Inout Pins\n";
    foreach my $pin (@inout_pins){
        print $vtb "wire $pin;\n";
    }
}

# Extra signal specified as reg for expected values of outputs
print $vtb "\n\n// Expected Outputs - Internal nets\n";
foreach my $pin (@output_pins){
    print $vtb "reg ${pin}_expected;\n";
    $pinalign = length($pin."_expected") if($pinalign < length($pin."_expected"));
}

# Extra signals specified as reg for expected values of inouts
# Extra signals to specify direction of inout pins: 0 - Out, 1 - In
if(defined $templatehash{inout_pins}){
    print $vtb "\n// Control for Inouts - Internal nets\n";
    foreach my $pin (@inout_pins){
        print $vtb "reg ${pin}_expected;\n";
        print $vtb "reg ${pin}_dir;\n";
        $pinalign = length($pin."_expected") if($pinalign < length($pin."_expected"));
    }
}

$pinalign+=2;

print $vtb "\ninteger failures=0,counter=0;\n";
print $vtb "\n\ninitial \nbegin
\t\$dumpfile\(\"${testbench}.vcd\"\);
\t\$dumpvars\(0," . (split("/",$testbench))[-1] . "\);
\t\$display();
\n\t#0\t\t// Bit 0\n";

for(my $simcount=0;$simcount < $simbits;$simcount++){
    foreach my $pin (@input_pins){
        next unless defined((split(//,$pinhash{$pin}))[$simcount]);
        my $pinval = (split(//,$pinhash{$pin}))[$simcount];
		printf $vtb "\t%-*s = %s\;\n",$pinalign,$pin,"1\'b$pinval" if($pinval=~/[01XZ]/i);
    }
    foreach my $pin (@output_pins){
		next unless defined((split(//,$pinhash{$pin}))[$simcount]);
		my $pinval = (split(//,$pinhash{$pin}))[$simcount];
		printf $vtb "\t%-*s = %s\;\n",$pinalign,"${pin}_expected","1\'b$pinval" if($pinval=~/[01XZ]/i);
    }

    if(defined $templatehash{inout_pins}){
        foreach my $pin (@inout_pins){
            next unless defined((split(//,$pinhash{$pin}))[$simcount]);
            my $pinval = (split(//,$pinhash{$pin}))[$simcount];

            # If L,H,Y is specified in signal vector for inout pin, treat it as input
            if($pinval=~/[LHY]/i){
                s/L/0/gi, s/H/1/gi, s/Y/X/gi for $pinval;
                printf $vtb "\t%-*s = %s\;    // inout\n",$pinalign,"${pin}_expected","1\'b$pinval";
                printf $vtb "\t%-*s = %s\;    // inout direction (0:Out, 1:In)\n",$pinalign,"${pin}_dir","1\'b1";
            
            # If 0,1,M,X,Z is specified in signal vector for inout pin, treat it as output
            }elsif($pinval=~/[01XZM]/i){
                s/M/X/gi for $pinval;
                printf $vtb "\t%-*s = %s\;    // inout\n",$pinalign,"${pin}_expected","1\'b$pinval";
                printf $vtb "\t%-*s = %s\;    // inout direction (0:Out, 1:In)\n",$pinalign,"${pin}_dir","1\'b0";
            }
        }
    }

	print $vtb "\t#$templatehash{waitstep}\n\tcounter = counter + 1\;\n\tevaluate_testbench\;\n";
	if($simcount < ($simbits -1)){
        $_=$simcount+1;
		print $vtb "\n\t#$templatehash{timestep}\t\t// Bit $_\n";
	}else{
		print $vtb "\n\tterminate_testbench\;\n";
	}
}
print $vtb "end\n\n";


if(defined $templatehash{inout_pins}){
    # Mux the value of inout pins with Z, controlled by the <inout>_in pin;
    # Give muxed value to DUT
    foreach my $pin (@inout_pins){
        print $vtb "assign $pin = ${pin}_dir ? ${pin}_expected : 1\'bZ;\n";
    }
}

print $vtb "
$templatehash{verilog_model} $templatehash{verilog_model}_dut ($templatehash{pin_order})\;\n

task terminate_testbench\;
begin
\t\$display\(\"Simulation found %0d failures\\n\", failures\)\;
\t\$finish\;
end
endtask
\n
task evaluate_testbench;
begin\n";

print $vtb "// Outputs comparison\n";
# Compare simulated output value with expected value
foreach my $pin (@output_pins){
#    print $vtb "\t\t\$strobe_compare(${pin}_expected,$pin);\n";
	print $vtb "\tif \(${pin}_expected !== 1'bX\) begin\n";
    print $vtb "\t\tif \(${pin}_expected !== $pin\) begin\n";
    print $vtb "\t\t\tfailures = failures + 1;\n";
    print $vtb "\t\t\$display\(\"Sim Failed for $pin in \%0d. Expected=\%d, Simulated=\%d\", counter,${pin}_expected,$pin)\;\n";
    print $vtb "\t\tend\n";
	print $vtb "\tend\n";
}

if(defined $templatehash{inout_pins}){
    # Compare simulated inout value with expected value if inout is treated as output
    print $vtb "\n// Inouts comparison\n";
    foreach my $pin (@inout_pins){
        print $vtb "\tif ((${pin}_dir === 1'b0)&&(${pin}_expected !==1'bX)) begin\n";
        print $vtb "\t\tif \(${pin}_expected !== $pin\) begin\n";
        print $vtb "\t\t\tfailures = failures + 1;\n";
        print $vtb "\t\t\$display\(\"Sim Failed for $pin in \%0d. Expected=\%d, Simulated=\%d\", counter,${pin}_expected,$pin)\;\n";
        print $vtb "\t\tend\n";
        print $vtb "\tend\n";
    }
}


print $vtb "end\nendtask\nendmodule\n";
close ($vtb);

my $command = "\\rm -rf INCA_libs ; /apps/ame/bin/ncverilog ./${testbench}.v -y ./${libdir} +libext+.v -l ${testbench}.log +define+TI_functiononly +define+TI_pupdmodeled +nocopyright +access+r";
print "\n  To verify your simulation execute\n    $command\n";

print "\n  Simulate? (Yes/No) : "; chomp($_=<STDIN>);
exec("$command") unless(/no?/i);
