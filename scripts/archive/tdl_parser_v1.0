#!/usr/bin/perl -l  

#***************************************************************************************************
#
# TDL Parser, creates CSV file from input TDL pattern file
# If regexp is supplied, reorders the pins in the CSV file and also generate a new TDL file
# 
# SYNTAX : tdl_parser -i <input filename> [-o <output filename>] [-p <regexp pattern>]
#
# Created by : Kartik Shenoy (a0393831)
#
# Changelog
#
# 2009-12-18
#   - Created
#
# 2009-12-23
#	- Added support for selective pin-name and state printing by specifying a
#     Perl-compatible regular expression
#
# 2009-12-24
#	- Reorders the pins in CSV file if regexp pattern is specified
#	- Regenerates a new TDL file based on the pin-order
#
#***************************************************************************************************


## Pragmas
use strict;
use diagnostics;
use Getopt::Long;


## Variable Declaration
my $fin;
my $fout;
my $pattern;
my $verbose;


## Command-line parameter handling
GetOptions(
	"ifile|i=s" => \$fin,
	"ofile|o:s" => \$fout,
	"pattern|p:s" => \$pattern,
	"verbose|v" => \$verbose,
);

defined($fin) || die("ERROR : Input file not specified");
open(FIN, "<$fin") || die("ERROR : Specified input file doesn't exist. Terminating");

unless(defined($fout) && ($fout ne "")){
	($fout) = ($fin =~ /(.*)(?:\.tdl)?$/);
	if(defined $pattern){
		warn "WARNING : Output file not specified. Writing output files ${fout}_out.tdl and $fout.csv";
		open(TDL, ">${fout}_out.tdl") || die "Unable to open ${fout}_out.tdl";
	}else{
		warn "WARNING : Output file not specified. Writing output to $fout.csv";
	}
}else{
	$fout =~ s/\.(?:tdl|csv)\.(?:csv|tdl)//;
	if(defined $pattern){
		print "Writing output files $fout.tdl and $fout.csv" if($verbose);
		open(TDL, ">$fout.tdl") || die "Unable to open $fout.tdl";
	}else{
		print "Writing output file to $fout.csv" if($verbose);
	}
}
open(CSV, ">${fout}.csv") || die "Unable to open ${fout}.csv";


## Regexp to accept everything by default unless defined
my $regexp=$pattern||'.*';


my $flag=0;
my @pins_all=();
## Merging input streams as it's spread over multiple lines;
while(chomp($_=<FIN>)){
	if(/^\s*VAR/||$flag){
		$flag=1;			# Set flag to indicate that loop should read lines from now on
		push(@pins_all,(/"(\w+)"/g));
		last if /\),\s*$/;
	}else{					# Move through input file making a copy in the tdlout till VAR is encountered
		print TDL if(defined $pattern);
		next;
	}
}
print "List of all pins :\n@pins_all" if($verbose);


my @pins;
my @pos;
if (defined $pattern){		# Reordering pins only if regexp pattern is specified
	my @pins_sel;
	my @pos_sel;

	foreach (0 .. $#pins_all){			# Separating pins into matched and unmatched arrays
		if($pins_all[$_]=~/$regexp/i){
			push(@pins_sel,$pins_all[$_]);
			push(@pos_sel,$_);
		}else{
			push(@pins,$pins_all[$_]);
			push(@pos,$_);
		}
	}
	@pins = (@pins_sel,@pins);
	@pos = (@pos_sel,@pos);
	
	print "\nList of reordered pins :\n@pins" if($verbose);
	print "\nList of reordered pin positions :\n@pos" if($verbose);
	
	$"="\", \"";
	print TDL "\tVAR = ( \"@pins\" ),";
	$"=" ";


	# Rearranging pin-definitions
	$flag=0;
	my @pindef;
	while(<FIN>){
		next unless(/DEFPIN/||$flag);
		chomp;
		$flag=1;
		push(@pindef,(/((?:OUT|IN)\s+\d+)/g));
		last if(/\);\s*$/);
	}
	print "\nPin Directions :\n@pindef" if($verbose);

	my $dir;
	my $count;
	my @pindef_expanded;
	foreach (@pindef){
	    ($dir,$count) = (/(OUT|IN) (\d+)/);
	    foreach (1 .. $count){
	        push(@pindef_expanded,$dir); 
	    }
	}
	@pindef_expanded = @pindef_expanded[@pos];
	print "\nExpanded Pin Directions :\n@pindef_expanded" if($verbose);

	$count=1;
	@pindef=();
	foreach my $i (1 .. $#pindef_expanded){
		if($pindef_expanded[$i] eq $pindef_expanded[$i-1]){
			$count++;
		}else{
			push(@pindef,"$pindef_expanded[$i-1] $count");
			$count=1;
		}
	}
	push(@pindef,"$pindef_expanded[$#pindef_expanded] $count");
	print "\nNew Pin Definition Order:\n@pindef" if($verbose);
	print TDL "\tDEFPIN = ( @pindef );";

}else{
	@pins = @pins_all;
	@pos = (0 .. $#pins_all);
	print "Not reordering pins as no pattern specified" if($verbose);
}
print CSV "@pins,";

$\="";
$/=";";
$"=",";
my $repeat=1;
my @states;
while(<FIN>){
	# This if condition identifies the states
	if(/(SETR P:=T')/){
		print TDL "$1" if(defined $pattern);
		@states=(/[01YZLHM]/g)[@pos];
		print CSV "@states,\n";
		print TDL @states if(defined $pattern);
		print TDL "';\n" if(defined $pattern);
		print "\nState : @states\n" if($verbose);
	}elsif(/(RUNP FOR (\d+);)/){
		print TDL "$1\n" if(defined $pattern);
		foreach(0 .. $2){
			print CSV "@states,\n";
		}
		print "Repeats $2 times\n" if($verbose);
	}
}
print TDL "END;" if(defined $pattern);

$"=" ";
$/="\n";

close(FIN);
close(CSV);
close(TDL) if(defined $pattern);
