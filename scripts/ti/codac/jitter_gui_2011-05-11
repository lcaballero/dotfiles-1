#!/usr/bin/perl

use strict;
use warnings;
use diagnostics;
use Data::Dumper;

use Tk 8.0;
use Tk::NoteBook;
use Tk::MsgBox;



#===============================================================================
# Variables
#
# sig_type      : 0 => Single-ended , 1 => Differential
# trig_type     : 0 => Ideal        , 1 => Reference
# ref_type      : 0 => Single-ended , 1 => Differential
# norm_sig_type : 0 => Single-ended , 1 => Differential
# norm_ref_type : 0 => Single-ended , 1 => Differential
#
my $sig_type=0;
my $trig_type=0;
my $ref_type=0;
my $norm_sig=0;
my $norm_sig_type=0;
my $norm_ref=0;
my $norm_ref_type=0;
my $txt_ent_sig_val="";
my $txt_ent_sign_val=0;
my $txt_lbl_trig_val;
my $txt_ent_trig_val="";
my $txt_ent_trign_val=0;
my $txt_lbl_norm_sig_pwr;
my $txt_ent_norm_sig_pwr="";
my $txt_lbl_norm_sig_gnd;
my $txt_ent_norm_sig_gnd=0;
my $txt_lbl_norm_ref_pwr;
my $txt_ent_norm_ref_pwr="";
my $txt_lbl_norm_ref_gnd;
my $txt_ent_norm_ref_gnd=0;
my $txt_ent_script;



#===============================================================================
# Components
#
my $mw=MainWindow->new;
$mw->geometry("+500+300");

# Menu Bar Buttons
my $mbar=$mw->Menu();
$mw->configure(-menu => $mbar);
    my $file=$mbar->cascade(-label=>"~File", -tearoff => 0);
    my $help=$mbar->cascade(-label =>"~Help", -tearoff => 0);
# File Menu
    $file->command(-label =>'~New     ', -command=>sub{&menu_file('n')}, -accelerator=>'Ctrl+N');
    $file->command(-label =>'~Open    ', -command=>sub{&menu_file('o')}, -accelerator=>'Ctrl+O');
    $file->command(-label =>'~Save    ', -command=>sub{&menu_file('s')}, -accelerator=>'Ctrl+S');
    $file->separator();
    $file->command(-label =>'~Quit    ', -command=>sub{exit}, -accelerator=>'Ctrl+Q');
# Help Menu
    $help->command(-label => 'Version');
    $help->separator;
    $help->command(-label => 'About');

# Menu Bar Accelerators
    $mw->bind('<Control-n>'=>sub{&menu_file('n')});
    $mw->bind('<Control-o>'=>sub{&menu_file('o')});
    $mw->bind('<Control-s>'=>sub{&menu_file('s')});
    $mw->bind('<Control-q>'=>sub{exit});


# Tabs
my $nb=$mw->NoteBook();

# Main Tab
    my $nb_main=$nb->add('main', -label=>'Main');

        my $frm_sig=$nb_main->Labelframe(-text=>'Signal');
            my $lbl_sig_dummy=$frm_sig->Label();
            my $rdb_sig_type_se=$frm_sig->Radiobutton(-text=>'Single-ended', -variable=>\$sig_type, -value=>'0', -command=>\&resolve_widgets);
            my $rdb_sig_type_diff=$frm_sig->Radiobutton(-text=>'Differential', -variable=>\$sig_type, -value=>'1', -command=>\&resolve_widgets);

            my $lbl_sig_val=$frm_sig->Label(-text=>'Sig Name');
            my $ent_sig_val=$frm_sig->Entry(-width=>'15', -textvariable=>\$txt_ent_sig_val);
            #$ent_sig_val->bind('<FocusIn>'=>sub{print "Entered entry\n"});

            my $lbl_sign_val=$frm_sig->Label(-text=>'Sig Name (n) ');
            my $ent_sign_val=$frm_sig->Entry(-width=>'15', -textvariable=>\$txt_ent_sign_val);


        my $frm_trig=$nb_main->Labelframe(-text=>'Trigger');
            my $rdb_trig_type_ideal=$frm_trig->Radiobutton(-text=>'Ideal', -variable=>\$trig_type, -value=>'0', -command=>\&resolve_widgets);
            my $rdb_trig_type_ref=$frm_trig->Radiobutton(-text=>'Reference', -variable=>\$trig_type, -value=>'1', -command=>\&resolve_widgets);

            my $rdb_ref_type_se=$frm_trig->Radiobutton(-text=>'Single-ended', -variable=>\$ref_type, -value=>'0', -command=>\&resolve_widgets);
            my $rdb_ref_type_diff=$frm_trig->Radiobutton(-text=>'Differential', -variable=>\$ref_type, -value=>'1', -command=>\&resolve_widgets);

            my $lbl_trig_val=$frm_trig->Label(-textvariable=>\$txt_lbl_trig_val);
            my $ent_trig_val=$frm_trig->Entry(-width=>'15', -textvariable=>\$txt_ent_trig_val);

            my $lbl_trign_val=$frm_trig->Label(-text=>'Ref Name (n) ');
            my $ent_trign_val=$frm_trig->Entry(-width=>'15', -textvariable=>\$txt_ent_trign_val);


        my $frm_norm_sig=$nb_main->Labelframe(-text=>'Signal Normalisation');
            my $chk_norm_sig=$frm_norm_sig->Checkbutton(-text=>'Normalise Signal', -variable=>\$norm_sig, -command=>\&resolve_widgets);

            my $rdb_norm_sig_type_stat=$frm_norm_sig->Radiobutton(-text=>'Static', -variable=>\$norm_sig_type, -value=>'0', -command=>\&resolve_widgets);
            my $rdb_norm_sig_type_dyn=$frm_norm_sig->Radiobutton(-text=>'Dynamic', -variable=>\$norm_sig_type, -value=>'1', -command=>\&resolve_widgets);

            my $lbl_norm_sig_pwr=$frm_norm_sig->Label(-textvariable=>\$txt_lbl_norm_sig_pwr, -anchor=>'w');
            my $ent_norm_sig_pwr=$frm_norm_sig->Entry(-width=>'15', -textvariable=>\$txt_ent_norm_sig_pwr);

            my $lbl_norm_sig_gnd=$frm_norm_sig->Label(-textvariable=>\$txt_lbl_norm_sig_gnd, -anchor=>'w');
            my $ent_norm_sig_gnd=$frm_norm_sig->Entry(-width=>'15', -textvariable=>\$txt_ent_norm_sig_gnd);

        my $frm_norm_ref=$nb_main->Labelframe(-text=>'Reference Normalisation');
            my $chk_norm_ref=$frm_norm_ref->Checkbutton(-text=>'Normalise Reference', -variable=>\$norm_ref, -command=>\&resolve_widgets);

            my $rdb_norm_ref_type_stat=$frm_norm_ref->Radiobutton(-text=>'Static', -variable=>\$norm_ref_type, -value=>'0', -command=>\&resolve_widgets);
            my $rdb_norm_ref_type_dyn=$frm_norm_ref->Radiobutton(-text=>'Dynamic', -variable=>\$norm_ref_type, -value=>'1', -command=>\&resolve_widgets);

            my $lbl_norm_ref_pwr=$frm_norm_ref->Label(-textvariable=>\$txt_lbl_norm_ref_pwr);
            my $ent_norm_ref_pwr=$frm_norm_ref->Entry(-width=>'15', -textvariable=>\$txt_ent_norm_ref_pwr);

            my $lbl_norm_ref_gnd=$frm_norm_ref->Label(-textvariable=>\$txt_lbl_norm_ref_gnd);
            my $ent_norm_ref_gnd=$frm_norm_ref->Entry(-width=>'15', -textvariable=>\$txt_ent_norm_ref_gnd);

# Misc Tab
    my $nb_misc=$nb->add('misc', -label=>'Misc');





#===============================================================================
# Geometry Management
#

$nb->grid(-ipadx=>2, -ipady=>3, -padx=>2, -pady=>3);
{
    $frm_sig->grid(-row=>0, -column=>0, -sticky=>'news', -padx=>2);
    $frm_sig->gridColumnconfigure(0, -weight=>1);
    $frm_sig->gridRowconfigure(0, -weight=>1);
    {
        $rdb_sig_type_se->grid(-row=>1, -column=>0, -sticky=>'w');
        $rdb_sig_type_diff->grid(-row=>1, -column=>1, -sticky=>'w');

        $lbl_sig_val->grid(-row=>2, -column=>0, -sticky=>'w');
        $ent_sig_val->grid(-row=>2, -column=>1, -sticky=>'w');

        $lbl_sign_val->grid(-row=>3, -column=>0, -sticky=>'w');
        $ent_sign_val->grid(-row=>3, -column=>1, -sticky=>'w');
    }
    $frm_trig->grid(-row=>0, -column=>1, -sticky=>'news', -padx=>2);
    $frm_trig->gridColumnconfigure(0, -weight=>1);
    {
        $rdb_trig_type_ideal->grid(-row=>0, -column=>0, -sticky=>'w');
        $rdb_trig_type_ref->grid(-row=>0, -column=>1, -sticky=>'w');

        $rdb_ref_type_se->grid(-row=>1, -column=>0, -sticky=>'w');
        $rdb_ref_type_diff->grid(-row=>1, -column=>1, -sticky=>'w');

        $lbl_trig_val->grid(-row=>2, -column=>0, -sticky=>'w');
        $ent_trig_val->grid(-row=>2, -column=>1, -sticky=>'w');

        $lbl_trign_val->grid(-row=>3, -column=>0, -sticky=>'w');
        $ent_trign_val->grid(-row=>3, -column=>1, -sticky=>'w');
    }
    $frm_norm_sig->grid(-row=>1, -column=>0, -sticky=>'news', -padx=>2);
    $frm_norm_sig->gridColumnconfigure(0, -weight=>1);
    {
        $chk_norm_sig->grid(-row=>0, -column=>0, -sticky=>'w', -columnspan=>2);

        $rdb_norm_sig_type_stat->grid(-row=>1, -column=>0, -sticky=>'w');
        $rdb_norm_sig_type_dyn->grid(-row=>1, -column=>1, -sticky=>'w');

        $lbl_norm_sig_pwr->grid(-row=>2, -column=>0, -sticky=>'w');
        $ent_norm_sig_pwr->grid(-row=>2, -column=>1, -sticky=>'w');

        $lbl_norm_sig_gnd->grid(-row=>3, -column=>0, -sticky=>'w');
        $ent_norm_sig_gnd->grid(-row=>3, -column=>1, -sticky=>'w');
    }
    $frm_norm_ref->grid(-row=>1, -column=>1, -sticky=>'news', -padx=>2);
    $frm_norm_ref->gridColumnconfigure(0, -weight=>1);
    {
        $chk_norm_ref->grid(-row=>0, -column=>0, -sticky=>'w', -columnspan=>2);

        $rdb_norm_ref_type_stat->grid(-row=>1, -column=>0, -sticky=>'w');
        $rdb_norm_ref_type_dyn->grid(-row=>1, -column=>1, -sticky=>'w');

        $lbl_norm_ref_pwr->grid(-row=>2, -column=>0, -sticky=>'w');
        $ent_norm_ref_pwr->grid(-row=>2, -column=>1, -sticky=>'w');

        $lbl_norm_ref_gnd->grid(-row=>3, -column=>0, -sticky=>'w');
        $ent_norm_ref_gnd->grid(-row=>3, -column=>1, -sticky=>'w');
    }
}


&resolve_widgets;
&mw_redraw;


MainLoop;





#===============================================================================
# Sub-routines
#
sub resolve_widgets {

    if($sig_type){
        $lbl_sign_val->configure(-state=>'normal');
        $ent_sign_val->configure(-state=>'normal');
    }else{
        $lbl_sign_val->configure(-state=>'disabled');
        $ent_sign_val->configure(-state=>'disabled');
    }

    $txt_lbl_trig_val = ($trig_type == 0 ? 'Frequency' : 'Ref Name');

    if($trig_type){
        $rdb_ref_type_se->configure(-state=>'normal');
        $rdb_ref_type_diff->configure(-state=>'normal');
    }else{
        $rdb_ref_type_se->configure(-state=>'disabled');
        $rdb_ref_type_diff->configure(-state=>'disabled');
        $lbl_trign_val->configure(-state=>'disabled');
        $ent_trign_val->configure(-state=>'disabled');
    }

    if($trig_type and $ref_type){
        $lbl_trign_val->configure(-state=>'normal');
        $ent_trign_val->configure(-state=>'normal');
    }else{
        $lbl_trign_val->configure(-state=>'disabled');
        $ent_trign_val->configure(-state=>'disabled');
    }

    $txt_lbl_norm_sig_pwr = ($norm_sig_type == 0 ? 'Power (val)'  : 'Power (sig)');
    $txt_lbl_norm_sig_gnd = ($norm_sig_type == 0 ? 'Ground (val)' : 'Ground (sig)');

    foreach ($rdb_norm_sig_type_stat,$rdb_norm_sig_type_dyn,$lbl_norm_sig_pwr,$ent_norm_sig_pwr,$lbl_norm_sig_gnd,$ent_norm_sig_gnd){
        if($norm_sig){
            $_->configure(-state=>'normal');
        }else{
            $_->configure(-state=>'disabled');
        }
    }

    if($trig_type){
        $chk_norm_ref->configure(-state=>'normal');
    }else{
        $chk_norm_ref->configure(-state=>'disabled');
    }

    $txt_lbl_norm_ref_pwr = ($norm_ref_type == 0 ? 'Power (val)'  : 'Power (sig)');
    $txt_lbl_norm_ref_gnd = ($norm_ref_type == 0 ? 'Ground (val)' : 'Ground (sig)');

    foreach ($rdb_norm_ref_type_stat,$rdb_norm_ref_type_dyn,$lbl_norm_ref_pwr,$ent_norm_ref_pwr,$lbl_norm_ref_gnd,$ent_norm_ref_gnd){
        if($trig_type and $norm_ref){
            $_->configure(-state=>'normal');
        }else{
            $_->configure(-state=>'disabled');
        }
    }
}


sub mw_redraw {
    $mw->idletasks;

    my $w=$mw->reqwidth;
    my $h=$mw->reqheight;
    #print "MW: MinWidth=$w, MinHeight=$h\n";

    $mw->geometry("${w}x${h}");
    $mw->minsize($w,$h);

    $mw->resizable(0,0);
}


sub menu_file {
    my $opt=shift;

    my $filetypes = [
        ['Codac files', '.k'],
        ['All Files',  '*'  ],
    ];

    if($opt eq 'n'){
        $sig_type=0;
        $trig_type=0;
        $ref_type=0;
        $norm_sig=0;
        $norm_sig_type=0;
        $norm_ref=0;
        $norm_ref_type=0;
        $txt_ent_sig_val="";
        $txt_ent_sign_val=0;
        $txt_ent_trig_val="";
        $txt_ent_trign_val=0;
        $txt_ent_norm_sig_pwr="";
        $txt_ent_norm_sig_gnd=0;
        $txt_ent_norm_ref_pwr="";
        $txt_ent_norm_ref_gnd=0;

    }elsif($opt eq 'o'){
        my $fname = $mw->getOpenFile(-filetypes=>$filetypes, -defaultextension=>'.k');
        &script_parse($fname);

    }elsif($opt eq 's'){
        $txt_ent_script = $mw->getSaveFile(-filetypes=>$filetypes, -initialfile=>'jitter', -defaultextension=>'.k');
        &input_chk;
        &script_gen;
    }
}


sub script_parse {
}


sub input_chk {

    warn "  WARN: Missing Input - Signal Name\n" and return(1) 
        if($txt_ent_sig_val =~ /^\s*$/);
    warn "  WARN: Missing Input - Signal Name (n)\n" and return(1) 
        if($sig_type and $txt_ent_sign_val =~ /^\s*$/);
    
    warn "  WARN: Missing Input - Reference Frequency\n" and return(1)
        if(!$trig_type and $txt_ent_trig_val =~ /^\s*$/);
    warn "  WARN: Missing Input - Reference signal\n" and return(1)
        if($trig_type and !$ref_type and $txt_ent_trig_val =~ /^\s*$/);
    warn "  WARN: Missing Input - Reference signal (n)\n" and return(1)
        if($trig_type and $ref_type and $txt_ent_trign_val =~ /^\s*$/);

    warn "  WARN: Missing Input - Signal Power\n" and return(1)
        if($norm_sig and $txt_ent_norm_sig_pwr =~ /^\s*$/);
    warn "  WARN: Missing Input - Signal Ground\n" and return(1)
        if($norm_sig and $txt_ent_norm_sig_gnd =~ /^\s*$/);

    warn "  WARN: Missing Input - Reference Power\n" and return(1)
        if($trig_type and $norm_ref and $txt_ent_norm_ref_pwr =~ /^\s*$/);
    warn "  WARN: Missing Input - Reference Ground\n" and return(1)
        if($trig_type and $norm_ref and $txt_ent_norm_ref_gnd =~ /^\s*$/);

    warn "  WARN: Missing Input - Output Script Name\n" and return(1)
        if($txt_ent_script =~ /^\s*$/);
}


sub script_gen {

    open(my $fout,">",$txt_ent_script) or die("ERROR: Unable to open $txt_ent_script for writing\n");

    print $fout '#!/apps/ame/bin/codac
/*

    Codac Script to calculate P2P, C2C and Source-synchronous Jitter
    Auto-generated by perl-codac script generator
';
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
    $year += 1900; # $year contains no. of years since 1900
    my @month_abbr = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
    print $fout "    Timestamp: $hour:$min:$sec - $month_abbr[$mon] $mday, $year\n";

    print $fout '
    SYNTAX: codac <jitter> <punchfile>

    DESCRIPTION:
      The name of the signal should be specified in "sig_prenorm","sign_prenorm"

      Setup:-
        Setup should be specified by setting the variable "setup" to "Normal" or "SrcSyn"
        Normal mode is to measure jitter of one/same signal at different points in the circuit
          eg. To measure jitter at pad/y etc for LVCMOS Tx/Rx

      Trigger:-
        Jitter calculation can be performed with respect to an ideal trigger or a reference signal
          by setting the variable "trigger" to "Ideal" or "Reference" respectively
        When ideal trigger is selected, the frequency should be specified in "ref_freq"
        When trigger=Reference, the name of the reference signal should be set in "ref_prenorm","refn_prenorm"

      Normalisation:-
        Supports normalisation of signal (and independently of the reference if selected) prior to jitter computation.
        Normalisation can be selected by setting the variables "norm_type_sig" and "norm_type_ref"
        Normalisation modes supported are "Static", "Dynamic" and "None"
        To disable normalisation, set variables "norm_type_*" to "None"
        To perform static normalisation, the DC values of the supplies (and ground)
          should be set using the variables "*_pwr_dc" and "*_gnd_dc"
        To perform dynamic normalisation, the supplies themselves should be punched and
          the variables "*_pwr" and "*_gnd" should be set appropriately

    CHANGELOG:
      2011-05-05: Added support for source-synchronous jitter measurements

*/


string unitify(float inum){
    string ostr;
    float num=abs(inum);

    if(num >= 1){
        ostr=str(num);
    }else if(num >= 1e-3){
        sprintf(ostr,"%.3fm",num*1e3);
    }else if(num >= 1e-6){
        sprintf(ostr,"%.3fu",num*1e6);
    }else if(num >= 1e-9){
        sprintf(ostr,"%.3fn",num*1e9);
    }else if(num >= 1e-12){
        sprintf(ostr,"%.3fp",num*1e12);
    }else{
        sprintf(ostr,"%.3ff",num*1e15);
    }

    if(inum < 0){
        sprintf(ostr,"-%s",ostr);
    }
    return(ostr);
}


main(string ifile){

/* Variable declaration */
    waveform sig,sig_prenorm,sign_prenorm;
    waveform sig_pwr,sig_gnd;
    waveform ref,ref_prenorm,refn_prenorm;
    waveform ref_pwr,ref_gnd;

    int tran,tran_start,tran_stop,tran_total_sig,tran_total_ref,tran_sig,tran_sig_next;
    int num_odd,num_even;

    float ref_freq,ui;
    float sig_pwr_dc,ref_pwr_dc;
    float time,time_stop;
    float delta,delta_odd_prev,delta_even_prev,delta_setup,delta_hold;
    float jitter_p2p_odd,jitter_p2p_even,jitter_p2p_period,jitter_c2c,jitter_srcsyn;

    string ofile;
    string trigger,norm_type_sig,norm_type_ref,setup;

    string str_delta_odd_min,str_delta_odd_max;
    string str_delta_even_min,str_delta_even_max;
    string str_jitter_c2c_odd_max,str_jitter_c2c_even_max;
    string str_jitter_p2p_odd,str_jitter_p2p_even,str_jitter_p2p_period;
    string str_jitter_srcsyn;
    string str_setup_max,str_setup_min,str_hold_max,str_hold_min;

    file fp;


/* Initialisation values. Don\'t change unless required */
    float delta_odd_min=1e34;
    float delta_odd_max=-1e34;
    float delta_even_min=1e34;
    float delta_even_max=-1e34;
    float delta_period_min=1e34;
    float delta_period_max=-1e34;
    float jitter_c2c_odd_max=-1e34;
    float jitter_c2c_even_max=-1e34;
    float setup_min=1e34;
    float setup_max=-1e34;
    float hold_min=1e34;
    float hold_max=-1e34;


    sprintf(ofile,"%s.txt",ifile);


/* The transition from  which computation must start */
    tran_start = 1;


/* Jitter setup to be used : Normal/SrcSyn */
/* Normal : Normal jitter setup, input and output are the same signal at different points in the circuit */
/* SrcSyn : Source-synchronous jitter setup */
    setup = "Normal";


/* Choose Trigger Type : Ideal/Reference */
/* Ideal     : Jitter calculations will be done wrt. an ideal clock of the specified frequency (ref_freq) */
/* Reference : Jitter calculations will be done wrt. the specified reference signal */
';

if($trig_type){
    print $fout "    trigger  = \"Reference\";\n";
    print $fout "    ref_freq = 1e8;\n";
}else{
    print $fout "    trigger  = \"Ideal\";\n";
    print $fout "    ref_freq = $txt_ent_trig_val;\n";
}

print $fout '

/* Normalisation Type : Dynamic/Static/None */
/* In case of Static normalisation, enter the DC values of the voltage sources, for input and sigput signals, below */
/* In case of Dynamic normalisation, ensure that the waveforms of the voltage sources, for input and sigput signals, are punched sig */
';
if($norm_sig==0){
    print $fout "    norm_type_sig = \"None\";\n";
}elsif($norm_sig==1 and $norm_sig_type==0){
    print $fout "    norm_type_sig = \"Static\";\n";
}elsif($norm_sig==1 and $norm_sig_type==1){
    print $fout "    norm_type_sig = \"Dynamic\";\n";
}
if($norm_ref==0){
    print $fout "    norm_type_ref = \"None\";\n";
}elsif($norm_ref==1 and $norm_ref_type==0){
    print $fout "    norm_type_ref = \"Static\";\n";
}elsif($norm_ref==1 and $norm_ref_type==1){
    print $fout "    norm_type_ref = \"Dynamic\";\n";
}

print $fout '

/* Reading waveforms */
    readspicepunch(ifile);
';
print $fout "    sig_prenorm = readwave(ifile,\"$txt_ent_sig_val\");\n";
if($sig_type){
    print $fout "    sign_prenorm = readwave(ifile,\"$txt_ent_sign_val\");\n";
}else{
    print $fout "    sign_prenorm = 0;\n";
}
print $fout '
    if(trigger=="Reference"){
';
if($trig_type){
    print $fout "        ref_prenorm = readwave(ifile,\"$txt_ent_trig_val\");\n";
}else{
    print $fout "        ref_prenorm = readwave(ifile,\"\");\n";
}
if($ref_type){
    print $fout "        refn_prenorm = readwave(ifile,\"$txt_ent_sign_val\");\n";
}else{
    print $fout "        refn_prenorm = 0;\n";
}

print $fout '    }


/* Supplies for signals */
    if(norm_type_sig=="Dynamic"){
';
if($norm_sig and $norm_sig_type){
    print $fout "        sig_pwr = readwave(ifile,\"$txt_ent_norm_sig_pwr\");\n";
    if($txt_ent_norm_sig_gnd=~/\w+/){
        print $fout "        sig_gnd = readwave(ifile,\"$txt_ent_norm_sig_gnd\");\n";
    }else{
        print $fout "        sig_gnd = $txt_ent_norm_sig_gnd;\n";
    }
}else{
    print $fout "        sig_pwr = readwave(ifile,\"\");\n";
    print $fout "        sig_gnd = 0;\n";
}
print $fout '    }else if(norm_type=="Static"){
';
if($norm_sig and !$norm_sig_type){
    print $fout "        sig_pwr_dc = $txt_ent_norm_sig_pwr;\n";
    print $fout "        sig_gnd_dc = $txt_ent_norm_sig_gnd;\n";
}else{
    print $fout "        sig_pwr_dc = 0;\n";
    print $fout "        sig_gnd_dc = 0;\n";
}
print $fout '    }
    if(trigger=="Reference" && norm_type_ref=="Dynamic"){
';
if($norm_ref and $norm_ref_type){
    print $fout "        ref_pwr = readwave(ifile,\"$txt_ent_norm_ref_pwr\");\n";
    if($txt_ent_norm_ref_gnd=~/\w+/){
        print $fout "        ref_gnd = readwave(ifile,\"$txt_ent_norm_ref_gnd\");\n";
    }else{
        print $fout "        ref_gnd = $txt_ent_norm_ref_gnd;\n";
    }
}else{
    print $fout "        ref_pwr = readwave(ifile,\"\");\n";
    print $fout "        ref_gnd = 0;\n";
}
print $fout '    }else if(trigger=="Reference" && norm_type_ref=="Static"){
';
if($norm_ref and !$norm_ref_type){
    print $fout "        ref_pwr_dc = $txt_ent_norm_ref_pwr;\n";
    print $fout "        ref_gnd_dc = $txt_ent_norm_ref_gnd;\n";
}else{
    print $fout "        ref_pwr_dc = 0;\n";
    print $fout "        ref_gnd_dc = 0;\n";
}

print $fout '    }


/* Converting differential single to single-ended (P-N) */
    sig_prenorm -= sign_prenorm;
    if(trigger=="Reference"){
        ref_prenorm -= refn_prenorm;
    }


/* Normalising the signals here */
/* Note that in the absence of ground noise, this reduces to (sig=sig_prenorm/sig_pwr) viz an accurate representation */
/* However, in the presence of ground noise, the below formula is only an approximation */
    if(norm_type_sig=="Dynamic"){
        printf("\nApplying Dynamic normalisation to the signal");
        sig = (sig_prenorm-sig_gnd)/(sig_pwr-sig_gnd);
    }else if(norm_type_sig=="Static"){
        printf("\nApplying Static normalisation to the signal");
        sig = (sig_prenorm-sig_gnd_dc)/(sig_pwr_dc-sig_gnd_dc);
    }else if(norm_type_sig=="None"){
        printf("\nNormalisation not done for the signal");
        sig = sig_prenorm;
    }else{
        printf("\nPlease enter proper normalisation type");
        exit(1);
    }
    if(trigger == "Reference"){
        if(norm_type_ref=="Dynamic"){
            printf("\nApplying Dynamic normalisation to the reference");
            ref = (ref_prenorm-ref_gnd)/(ref_pwr-ref_gnd);
        }else if(norm_type_ref=="Static"){
            printf("\nApplying Static normalisation to the reference");
            ref = (ref_prenorm-ref_gnd_dc)/(ref_pwr_dc-ref_gnd_dc);
        }else if(norm_type_ref=="None"){
            printf("\nNormalisation not done for the reference");
            ref = ref_prenorm;
        }else{
            printf("\nPlease enter proper normalisation type");
            exit(1);
        }
    }


    setsighigh(0.2,sig);
    setsigcent(0,sig);
    setsiglow(-0.2,sig);

    if(trigger=="Reference"){
        setsighigh(0.2,ref);
        setsigcent(0,ref);
        setsiglow(-0.2,ref);
    }


    if(setup=="SrcSyn"){

        if(trigger=="Reference"){
            tran_stop = gettransitions(ref);
        }else{
            tran_total_sig = gettransitions(sig);
            time_stop = gettransitiontime(sig,tran_total_sig);
            tran_stop = time_stop/(0.5/ref_freq) + 1;
        }

        for(tran=tran_start,tran_sig=tran_start;tran<=tran_stop;tran++){

            tran_sig_next=tran_sig+1;
            if(trigger=="Reference"){
                delta_setup = delay(ref,tran,sig,tran_sig);
                delta_hold  = delay(sig,tran_sig_next,ref,tran);
            }else{
/*                time=gettransitiontime(sig,tran);
                delta = time-(tran)*(0.5/ref_freq);
              printf("\n\n  %3d    : Time  = %e",tran,time);
*/          }

            if(delta_setup < ui){
                setup_min = min(setup_min,delta_setup);
                setup_max = max(setup_max,delta_setup);
/*              printf("\n    Setup : Delta = %e : Max = %e : Min = %e",delta_setup,delta_setup_max,delta_setup_min);*/
            }

            if(delta_hold < ui){
                hold_min = min(hold_min,delta_hold);
                hold_max = max(hold_max,delta_hold);
/*              printf("\n    Hold  : Delta = %e : Max = %e : Min = %e",delta_hold,delta_hold_max,delta_hold_min);*/

                tran_sig++;
            }

        }

        jitter_srcsyn = setup_max-setup_min;

        str_jitter_srcsyn = unitify(jitter_srcsyn);
        str_setup_max     = unitify(setup_max);
        str_setup_min     = unitify(setup_min);
        str_hold_max      = unitify(hold_max);
        str_hold_min      = unitify(hold_min);

        printf("\n");

        printf("Punch file      : %s\n",ifile);
        printf("\n");
        printf("Source-sync jitter = %s",str_jitter_srcsyn);
        printf("  Max Setup Time   = %s",str_setup_max);
        printf("  Min Setup Time   = %s",str_setup_min);
        printf("  Max Hold Time    = %s",str_hold_max);
        printf("  Min Hold Time    = %s",str_hold_min);

        printf("\n\n");

        fp=fopen(ofile,"w");
        fprintf(fp,"Punch file      : %s\n",ifile);
        fprintf(fp,"\n");
        fprintf(fp,"Source-sync jitter = %e",jitter_srcsyn);
        fprintf(fp,"  Max Setup Time   = %e",setup_max);
        fprintf(fp,"  Min Setup Time   = %e",setup_min);
        fprintf(fp,"  Max Hold Time    = %e",hold_max);
        fprintf(fp,"  Min Hold Time    = %e",hold_min);

        fclose(fp);

    }else{

        tran_total_sig = gettransitions(sig);
        if(trigger=="Reference"){
            tran_total_ref = gettransitions(ref);
            if(tran_total_ref != tran_total_sig){
                printf("\n\nWARNING : The number of transitions in the input and output signals do not match");
                printf("\n  Transitions in Signal    : %d",tran_total_sig);
                printf("\n  Transitions in Reference : %d",tran_total_ref);

                tran_stop = min(tran_total_ref,tran_total_sig);
                printf("\n  Computing till transition number %d",tran_stop);
            }else{
                tran_stop = tran_total_ref;
            }

        }else{
            tran_stop = tran_total_sig;
        }

        for(tran=tran_start;tran<=tran_stop;tran++){

            if(trigger=="Reference"){
                delta = delay(sig,tran,ref,tran);
            }else{
                time=gettransitiontime(sig,tran);
                delta = time-(tran)*(0.5/ref_freq);
/*              printf("\n\n  %3d    : Time  = %e",tran,time);*/
            }

            if((tran-tran_start)%2==1){

                delta_odd_max = max(delta_odd_max,delta);
                delta_odd_min = min(delta_odd_min,delta);

                if(tran==tran_start+1){
                    delta_odd_prev = delta;
                    jitter_c2c = 0;
                }else{
                    jitter_c2c = fabs(delta-delta_odd_prev);
                    delta_odd_prev = delta;
                }

                if(jitter_c2c > jitter_c2c_odd_max){
                    jitter_c2c_odd_max = jitter_c2c;
                    num_odd = (tran)/2;
                }
/*              printf("\n    Odd  : Delta = %e : Max = %e : Min = %e",delta,delta_odd_max,delta_odd_min);*/
            }

            if((tran-tran_start)%2==0){

                delta_even_max = max(delta_even_max,delta);
                delta_even_min = min(delta_even_min,delta);

                if(tran==tran_start){
                    delta_even_prev = delta;
                    jitter_c2c = 0;
                }else{
                    jitter_c2c = fabs(delta-delta_even_prev);
                    delta_even_prev = delta;
                }

                if(jitter_c2c > jitter_c2c_even_max){
                    jitter_c2c_even_max = jitter_c2c;
                    num_even = (tran+1)/2;
                }
/*              printf("\n    Even : Delta = %e : Max = %e : Min = %e",delta,delta_even_max,delta_even_min);*/
            }

            delta_period_max = max(delta_period_max,delta);
            delta_period_min = min(delta_period_min,delta);
/*          printf("\n    Data : Delta = %e : Max = %e : Min = %e : Diff = %e",delta,delta_period_max,delta_period_min,delta_period_max-delta_period_min);*/

        } /* End of setup!="SrcSyn" -> for loop */


        jitter_p2p_odd    = delta_odd_max    - delta_odd_min;
        jitter_p2p_even   = delta_even_max   - delta_even_min;
        jitter_p2p_period = delta_period_max - delta_period_min;

        str_delta_odd_max       = unitify(delta_odd_max);
        str_delta_even_max      = unitify(delta_even_max);
        str_delta_odd_min       = unitify(delta_odd_min);
        str_delta_even_min      = unitify(delta_even_min);
        str_jitter_p2p_odd      = unitify(jitter_p2p_odd);
        str_jitter_p2p_even     = unitify(jitter_p2p_even);
        str_jitter_c2c_odd_max  = unitify(jitter_c2c_odd_max);
        str_jitter_c2c_even_max = unitify(jitter_c2c_even_max);
        str_jitter_p2p_period   = unitify(jitter_p2p_period);

        printf("\n");

        printf("Punch file      : %s\n",ifile);
        printf("\n");
        printf("Period jitter   = %s",str_jitter_p2p_period);
        printf("\n");
        if(isfall(sig,tran_start)){
            printf("P2P rise jitter = %s\n",str_jitter_p2p_odd);
            printf("C2C rise jitter = %s in transition no. %d\n",str_jitter_c2c_odd_max,num_odd);
            printf("Rise min delta  = %s ; max delta = %s\n",str_delta_odd_min,str_delta_odd_max);
            printf("\n");
            printf("P2P fall jitter = %s\n",str_jitter_p2p_even);
            printf("C2C fall jitter = %s in transition no. %d\n",str_jitter_c2c_even_max,num_even);
            printf("Fall min delta  = %s ; max delta = %s\n",str_delta_even_min,str_delta_even_max);
        }else{
            printf("P2P rise jitter = %s\n",str_jitter_p2p_even);
            printf("C2C rise jitter = %s in transition no. %d\n",str_jitter_c2c_even_max,num_even);
            printf("Rise min delta  = %s ; max delta = %s\n",str_delta_even_min,str_delta_even_max);
            printf("\n");
            printf("P2P fall jitter = %s\n",str_jitter_p2p_odd);
            printf("C2C fall jitter = %s in transition no. %d\n",str_jitter_c2c_odd_max,num_odd);
            printf("Fall min delta  = %s ; max delta = %s\n",str_delta_odd_min,str_delta_odd_max);
        }
        printf("\n\n");

        fp=fopen(ofile,"w");
        fprintf(fp,"Punch file      : %s\n",ifile);
        fprintf(fp,"\n");
        fprintf(fp,"Period jitter   = %e\n",jitter_p2p_period);
        fprintf(fp,"\n");
        if(isfall(sig,tran_start)){
            fprintf(fp,"P2P rise jitter = %e\n",jitter_p2p_odd);
            fprintf(fp,"C2C rise jitter = %e in transition no. %d\n",jitter_c2c_odd_max,num_odd);
            fprintf(fp,"Rise min delta  = %e ; max delta = %e\n",delta_odd_min,delta_odd_max);
            fprintf(fp,"\n");
            fprintf(fp,"P2P fall jitter = %e\n",jitter_p2p_even);
            fprintf(fp,"C2C fall jitter = %e in transition no. %d\n",jitter_c2c_even_max,num_even);
            fprintf(fp,"Fall min delta  = %e ; max delta = %e\n",delta_even_min,delta_even_max);
        }else{
            fprintf(fp,"P2P rise jitter = %e\n",jitter_p2p_even);
            fprintf(fp,"C2C rise jitter = %e in transition no. %d\n",jitter_c2c_even_max,num_even);
            fprintf(fp,"Rise min delta  = %e ; max delta = %e\n",delta_even_min,delta_even_max);
            fprintf(fp,"\n");
            fprintf(fp,"P2P fall jitter = %e\n",jitter_p2p_odd);
            fprintf(fp,"C2C fall jitter = %e in transition no. %d\n",jitter_c2c_odd_max,num_odd);
            fprintf(fp,"Fall min delta  = %e ; max delta = %e\n",delta_odd_min,delta_odd_max);
        }
        fclose(fp);

    } /* End of setup!="SrcSyn" */

}
';

close $fout;
}
